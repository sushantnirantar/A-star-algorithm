# a0
                                                                   route_pichu - A maze problem
Introduction - The problem requires us to find the shortest path from pichu to us. The Room map has been abstracted as a matrix of (m * n) size where '.' represents a free space and allows pichu to move through it, 'p' is the location of pichu, 'X' represents a wall which block movement of pichu and finally '@' represents our location. This matrix representation of the room can be easily read by assigning each position on the matrix a 2-D coordinate value (Starting from (0,0) to (m-1,n-1)).
Valid State set - The valid state set contains all the matrix arrangement of map where pichu's location (coordinate) is inside the map and not on a position occupied by wall. In other words for a state to be valid pichu's location coordinates ranges from (0,0) to (m-1,n-1) excluding all coordinates of wall, according to our abstraction.
Successor Function - The successor function in our code is defined by moves() function which returns a list of valid moves from a given position. Pichu is allowed to move in only 4 primary directions, i.e. U,D,L,R. The list returned by moves() may return all 4 moves or less depending on validity of move as described above.
Cost Function - The cost of movement of pichu is constant and is '1' for each move. It is used to keep track of distance travelled by pichu from initial location.
Goal State - According to our abstraction, goal state is achieved when pichu_loc = my_loc. i.e pichu reaches us successfully using shortest path available.
Initial State - The initial state is the map that is given as input and has pichu on it's original location.

Reason for why the Program fail and Solution proposed - 
The skeleton code fails to find a solution because it keeps revisiting already explored states and hence goes in infinite loop. Also the code is implementing Depth First Search (DFS) as the code was implementing .pop() without any argument value, which pops the last element from the list. DFS is useful when we just need to find a solution and not the best available solution. The solution found by DFS may or may not be optimal. In my proposed solution, I am implementing Breadth First Search(BFS), because we are more concerned with finding the shortest path, since the cost function is uniform and BFS explores the search tree by level we are guarenteed to find optimal solution with BFS, if it exists. We can implement BFS by appending new state to fringe (which appends at the last position) and popping it from fringe from index 0 using pop(0) instead of pop(), this will ensure that the we implement a queue instead of stack, which ensures the states are explored in order that they were encountered.
To solve the problem of re exploring already visited states, I have implemented a visited set, the reason I used set instead of list is that set will eliminate duplicacy. The visited set stores the position currently being explored (Just after popping from fringe) and all previously explored positions. Then if the successor move/state in not in visited it is checked for presence of goal condition(i.e.if successor(curr_pos)==my_loc), else it is appended to the fringe.
Along with this I have also implemented dictionary for path, named solu to store current move's successor states. This dictionary looks like {(0,0):[(0,1),(1,0)]} where (0,0) or key is the current position/node being explored and [(0,1),(1,0)] are the valid successors of the key ((0,0)). To implement storing a list of values in dictionary, I used setdefault(currmove, []) method.
Then I have created a separate solu_keys and solu_values to extract keys and values from dictionary using .values() and .keys(). These dictvalues and dictkeys are then stored as list to iterate over them, they are stored as sol_val and sol_key.
For checking if the maze has a solution, I checked for presence of my_loc in item in sol_val (sol_val stores the values of dictionary i.e. [(0,1),(1,0)] as an item of the above illustration). After that I backtracked from my_loc to pichu_loc using the sol_val and sol_key using key values, i.e. setting value as my_loc and finding it's key which is the position that has my_loc in it's successor list, then this key is set as value and it's key is found, this process is repeated until pichu_loc is reached. This path is stored as a list containing the coordinate path from my_loc to pichu_loc. This solution list is then reversed to find the real path from pichu_loc to my_loc. These list elements are then passed as pairs through a check_mov() function to assign a move(U,D,L,R). This is then stored as a string. The length of solution list is the shortest path and the string is the moves that need to be followed to reach from pichu_loc to my_loc. This is returned as a pair (path_length, path_string).
If my_loc is not in any element of the sol_val list then (-1,"") is returned.

                                                                 arrange_pichus - An arrangement problem
Introduction - The problem requires us to find the arrangement of k pichus on a given (m * n) matrix such that no pichu attacks the others, two pichus are said to be in an attacking position if, (i) They are in the same row, (ii) They are in the same column or (iii) They are on the same diagonal. Pichus can occupy any of the empty space denoted in our abstraction as '.'. If a wall is in line of sight of pichu and they cannot see each other, they won't attack each other(i.e. if there's a wall between 2 pichus either row, column or diagonal). For this problem our location denoted by '@' also acts as a wall.
Valid State set - The valid state set contains all the arrangement of the number of pichus present on map at any given moment such that they do not attack each other, and the other constraints are similar to the above problem, them being any pichu's position must be within the matrix i.e.(0,0) to (m-1,n-1), and pichu must occupy the empty position '.' and not position of wall 'X' or my_loc '@'.
Successor Function - The successor function in our given code is aptly named successors() which takes a house_map as input and returns a list of all possible map arrangements such that pichu is occupying '.' position. i.e. The successor function returns a list of house_map such that the newly added pichu is placed on all possible empty space. This creates a large branching factor for our problem(which becomes a problem further down in the solution but was mitigated by removing invalid states from fringe and not exploring them.).
Cost Function - The problem of arranging pichus is not concerned with the cost of placing a pichu on map, our only concern is finding a map such that all pichus on that map not attack each other, but we can assume cost of placing a pichu on given position as constant and to simplify even further cost can be assumed equal to 1 for placing pichu on given position.
Goal state - According to the abstraction, the goal state is any arrangement of k number of pichus on the given map such that they do not attack each other.
Initial state - The initial state is the house_map with or without any pichu on it.

Reason why the skeleton code fails and proposed solution - 
The skeleton code fails to find a solution because the is_goal() function simply counts the number of pichus on any given arrangement and if it's equal to k it returns that as solution, it does not check for attacks from one pichu to other and hence the solution given by it is not what is desired. In my proposed solution, the problem after abstraction becomes a search problem and I'm implementing BFS, just because of it's completeness.
For keeping track of the attacking positions, I have implemented a set data structure named block_list. The block_list stores the coordinates of all positions that are attacked by the pichus in the given map arrangement. To tackle the problem posed by walls, instead of blocking the whole row and column for the pichu, I divided the movements into 8 parts, 4 for basic directions and 4 for diagonals, this was done to check the position of wall relative to pichu, so that the coordinates that are 'in front' of wall are not blocked because of the pichu being explored. Set gives us that functionality, to simply subtract A set from B to get all the values that are in A and not in B, doing this for all 8 directions we are able to free up the positions that are 'in front' of wall and block off the positions in between pichu and wall, the blocked positions are added to block_list.
In my updated is_goal() function, we get a list of all pichus on the given arrangement, the wall_list is obtained using return_wall_list() function which takes house_map as input and returns the positions of all walls on the map as list.
From the pichu_list, the position of first occurence of pichu is 'popped' from the list and it's initial block_list is created for all 8 sides (4 primary directions and 4 diagonals). Then a loop is run over wall_list, to check for occurence of wall in all 8 directions, if a wall appears in any direction, that direction's block list is updated and positions 'in front' of the wall are rempved from the block_list. After the directional block lists are made, the block_list is created by unioning all 8 part block lists.
A loop is run over the pichu_list to check for the presence of picu in block_list, if pichu occurs in block list the is_goal() function returns (1, False). If pichu is not in the block_list, the above steps are repeated to created the 8 direction part block list for this new pichu, these are then unioned to the original block_list(one that was calculated before loop).
If the number of pichus on the arrangement is equal to k, the is_goal() function returns (0, True), else if no pichu are in attacking position on the given arrangement but the number of pichus is not equal to k, the function returns (0, False)
The is_goal() function is called within the solve() function, if the new_house_map in successors is goal state, it returns (new_house_map, True) otherwise the first return argument of is_goal() is checked, if it is equal to 0, the new_house_map is added to fringe, if it is not equal to 0, the new_house_map is not added to fringe. The reason for tweaking the return type of is_goal() function to include 0 or 1 is to eliminate exploration of states that already have pichus in attacking position. 0 denotes no attacking position in the given arrangement and any value other than 0 indicates attacking states. The above steps are repeated until a solution is found(if it exists).
The goal state is returned by the solve() function and is displayed.







